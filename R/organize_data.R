#' Organize data before estimation
#'
#' This function converts a full conjoint data set to a data set structured for analyzing a specific attribute of interest and specific level(s) of interest.
#' This function receives input from reshape_data() and its output feeds into pj_estimate().
#' @import dplyr
#' @import tidyr
#' @import stringr
#' @import rlang
#' @import tidyselect
#' @param .dataframe A data frame to reorganize -- the second element of the list generated by reshape_conjoint()
#' @param .attribute A character column name identifying the attribute of interest
#' @param .level  A character vector identifying the levels of interest. Its length should be 1 for profile-level analysis and 2 for choice-level analysis
#' @param .structure either "choice_level" or "profile_level"
#' @param .remove_ties TRUE if you want to remove ties for the attribute of interest (in profile-level analysis)
#' @param .repeated_task TRUE if a repeated task is used to calculate IRR (recommended)
#' @keywords internal

organize_data <- function(
    .dataframe,
    .attribute,
    .level,
    .structure,
    .remove_ties,
    .repeated_task
){
  
  # bind variables locally to the function ----------------------------------
  
  id <- NULL
  selected <- NULL
  selected_repeated <- NULL
  selected_2 <- NULL
  att <- NULL
  task <- NULL
  ties <- NULL
  disagree <- NULL
  profile <- NULL
  att_1 <- NULL
  att_2 <- NULL
  
  # check various settings --------------------------------------------------
  
  structure  <- rlang::arg_match0(.structure, c("choice_level", "profile_level"))
  
  # specify the attributes and levels of interest
  att_levels <- stringr::str_c(.attribute, ":", .level)
  
  n_levels <- length(att_levels)
  
  if (structure == "profile_level" & n_levels == 2){
    
    stop("Specify 1 level for profile-level analysis")
    
  } else if (structure == "choice_level" & n_levels != 2){
    
    stop("Specify 2 levels for choice-level analysis")
    
  }
  
  
  # add a variable indicating disagreement ----------------------------------
  
  if (.repeated_task == TRUE){
    
    out1 <- .dataframe %>% 
      dplyr::mutate(disagree = ifelse(selected != selected_repeated, 1, 0))
    
  } else{
    
    out1 <- .dataframe %>% 
      dplyr::mutate(disagree = NA) 
  }
  
  # organize the data frame -------------------------------------------------
  
  # keep relevant rows only
  out2 <- out1 %>% 
    dplyr::rename(att = !!rlang::sym(.attribute)) %>% 
    dplyr::filter(att %in% att_levels)
  
  if (structure == "profile_level"){
    
    if (.remove_ties == TRUE){
      
      out2 <- out2 %>% 
        dplyr::group_by(id, task) %>% 
        dplyr::mutate(ties = n() - 1) %>% 
        dplyr::ungroup() %>% 
        dplyr::filter(ties == 0) %>% 
        dplyr::select(-ties)
      
    }
    
  } else if (structure == "choice_level"){
    
    out2 <- out2 %>% 
      
      # pivot the data frame
      tidyr::pivot_wider(id_cols = c(id, task, disagree), 
                         names_from = profile,
                         values_from = c(att, selected)) %>% 
      
      # keep relevant rows only
      dplyr::filter(att_1 == att_levels[1] & att_2 == att_levels[2]) %>% 
      
      # make "selected"
      dplyr::mutate(selected = selected_2) %>% 
      
      # add a column to record the levels of interest
      dplyr::mutate(att = str_c(att_levels, collapse = ", "))
    
  }
  
  # Keep necessary variables only and return --------------------------------
  
  # data frame to estimate IRR
  data1 <- out1 %>% 
    dplyr::select(id, disagree) %>% 
    dplyr::filter(!is.na(disagree)) %>% 
    dplyr::distinct() %>% 
    tibble::as_tibble()
  
  # data frame to estimate MM or AMCE
  data2 <- out2 %>% 
    dplyr::select(id, task, att, selected, disagree)
  
  list("data_for_irr" = data1, 
       "data_for_estimand" = data2) %>% 
    return()
  
}
